# CCS IDE 

## CCS 简介

​	Code Composer Studio是支持C2000MCU和嵌入式处理器的集成开发环境IDE。其集成了一套嵌入式应用的开发和调试工具链。目前最新版本为20.2.0，其界面风格以及使用的软件架构都与Microsoft的Visual Stuidio Code一致。最新版对于适应VSCode的开发者来说相当友好。

## C2000 Ware

​	该软件包是TI提供给C2000MCU开发使用的SDK，里面包括了一些工程模板跟示例，还有相关的库函数文件，还有系统配置工具SysconfigTool，可以以图形化方式快速配置初始外设相关的代码，其自动生成与ST的STM32CubeMX功能类似。

## CCS 新建工程流程

​	打开CCS会自动弹出一个开始界面菜单，与VScode一致，可以在开始界面菜单中选择新建一个工程“Create a new project”。

![image-20250829084925659](C:\Users\10637\AppData\Roaming\Typora\typora-user-images\image-20250829084925659.png)

​	然后会跳转到Project Wizard界面，在该界面下可以选择新建工程的一些参数，如芯片型号，C2000Ware版本，编译器版本等。

![image-20250829085516695](C:\Users\10637\AppData\Roaming\Typora\typora-user-images\image-20250829085516695.png)

​	此时右下角的"CREATE"按键是不可响应的，我们还需要在Examples中选择新建的工程目标，其中一些示例工程包含一些以及配置好的功能，对于初学者来说比较友好，如果想新建一个完全空白的基础工程，可以划到最下面选择Universal C2000。然后点击创建就会在WORKSPACE_CCSTHEIA默认工作区下创建工程。

![image-20250829090021551](C:\Users\10637\AppData\Roaming\Typora\typora-user-images\image-20250829090021551.png)

## 工程配置

​	右键工程名，选择最下方的”Properties“，就会弹出工程属性界面。

![image-20250829090226121](C:\Users\10637\AppData\Roaming\Typora\typora-user-images\image-20250829090226121.png)

* General：通用配置，在Connection中可以选择连接的仿真器型号；
  * Dependencies：依赖的库文件，主要是C2000WARE的文件路径，以及SysconfigTool的路径。
  * Variables：是一些工程定义的文件路径变量。
* Build
  * Steps：可以配置需要的构建步骤；
  * Link Order：可以配置链接器的链接顺序优先级。
* Tools
  * Sysconfig：系统配置工具的属性；
  * C2000 Compiler：可以配置编译器相关的属性，比如：编译器优化，预定义符合，头文件路径等等；
  * C2000 Linker：配置链接器相关属性。

​	主要的一些配置已经介绍完毕，其余的可以自行探索。

# XDS100V3 Emulator

## YXDSP-XDS100V3 仿真器

​	按照TI原装XDS100v3方案制作，TI仅此唯-的XDS100v3方案，对于未来的TI ARM和DSP核，XDS 100V3升值空间巨大，支持USB2.0高速接口，相比XDS 100v2具有更高的JTAG速度，采用ESD静电保护器件，并对JTAG进行保护，通过14PIN兼容标准接口对目标芯片进行伤真调试，支持CCS5.2以上版本，免驱动，插上仿真器自动识别。

<img src="https://omo-oss-image.thefastimg.com/portal-saas/new2023021109000781783/cms/image/dd5a614a-fd12-4805-b9fd-b4d6f08b1185.png" alt="img" style="zoom:67%;" />

## TI XDS100V3 仿真器

​	简单来说，它是一个 **“桥梁”** 或 **“诊断工具”**，连接你的电脑和基于TI芯片的电路板（称为“目标板”），主要用来**下载、调试、测试和优化**你编写在芯片里运行的软件（嵌入式程序）。作用如下：	

### 1. **程序下载（Programming / Flashing）**

- **用途**：将你在电脑上编写并编译好的程序代码（通常是`.out`或`.hex`文件）**烧录**到目标板的芯片存储器（Flash 或 RAM）中。
- **类比**：就像用U盘把电影拷到智能电视里一样，仿真器把你写的程序“拷”到芯片里。

### 2. **代码调试（Debugging）** - **这是最主要的功能**

调试就是寻找和修复代码中的错误（Bug）。仿真器允许你高度控制芯片的执行，以便观察程序的行为：

- **设置断点 (Breakpoints)**：让程序在指定的代码行暂停，方便你检查此时变量的值、寄存器的状态、内存的内容等。就像给程序按下了“暂停键”。
- **单步执行 (Single-Stepping)**：让程序一条指令一条指令地执行，你可以仔细跟踪每一步的执行效果。
- **查看和修改变量/内存/寄存器**：在程序暂停时，你可以实时查看芯片内部几乎所有数据，甚至可以修改它们的值来测试不同情况。
- **调用堆栈查看 (Call Stack)**：如果程序崩溃了，你可以看到程序在崩溃前调用了哪些函数，层层回溯找到问题根源。

### 3. **实时运行和监控 (Real-Time Operation & Monitoring)**

- **用途**：让程序在全速运行的同时，通过仿真器回传一些调试信息（如打印日志、变量实时波形等）到电脑上，而不会严重影响芯片的正常工作。
- **例子**：一个电机控制程序正在全速运转电机，你可以同时在电脑屏幕上看到一个代表电机转速的变量波形图，实时观察它的变化。

### 4. **性能分析 (Profiling)**

- **用途**：分析代码的性能，例如统计某段代码执行花了多少时间，找出程序的瓶颈（最耗时的部分），从而进行优化。

### 5. **系统初始化与配置 (Initialization)**

- **用途**：对于复杂的芯片（如DSP、多核ARM），上电后需要配置大量时钟、内存控制器、外设等。仿真器可以帮你验证这些配置是否正确，或者直接通过调试脚本进行初始化。



## 14PIN JTAG 接口

​	这个接口常见于TI（德州仪器）的DSP、ARM等芯片的调试和编程，是标准20Pin接口的紧凑版本。

### 引脚定义

​	引脚编号顺序取决于你从哪个方向观察接口。通常，接口上会有一个**凹槽或白色三角**标记来指示第1引脚的位置。有凹槽一侧，以凹槽在上为标准，最右侧为1号引脚，其下为2号引脚，往左以此类推。

![image-20250821112418016](C:\Users\10637\AppData\Roaming\Typora\typora-user-images\image-20250821112418016.png)

### 引脚功能

| 引脚编号 | 信号名称            | 全称                     | 方向（对目标板而言） | 说明                                                         |
| :------- | :------------------ | :----------------------- | :------------------- | :----------------------------------------------------------- |
| 1        | **TDO**             | Test Data Out            | **输出**             | 测试数据输出。数据从目标芯片通过此引脚传送到调试器。         |
| 2        | **GND**             | Ground                   | -                    | **信号地**。提供信号参考地，**必须连接**。                   |
| 3        | **TDI**             | Test Data In             | **输入**             | 测试数据输入。数据从调试器通过此引脚传送到目标芯片。         |
| 4        | **GND**             | Ground                   | -                    | **信号地**。                                                 |
| 5        | **TMS**             | Test Mode Select         | **输入**             | 测试模式选择。用于控制JTAG状态机（TAP Controller）的状态转换。 |
| 6        | **GND**             | Ground                   | -                    | **信号地**。                                                 |
| 7        | **TCK**             | Test Clock               | **输入**             | 测试时钟。为JTAG通信提供同步时钟信号，由调试器产生。         |
| 8        | **GND**             | Ground                   | -                    | **信号地**。                                                 |
| 9        | **nTRST**           | Test Reset (active low)  | **输入** (可选)      | 测试复位（低电平有效）。用于异步复位JTAG的TAP控制器。**此信号是可选的**，但连接后调试更可靠。 |
| 10       | **GND**             | Ground                   | -                    | **信号地**。                                                 |
| 11       | **RTCK**            | Return Test Clock        | **输出** (可选)      | 返回测试时钟。用于自适应时钟（Adaptive Clocking），目标板将时钟返回给调试器以同步速率。**此信号是可选的**，常见于ARM芯片。 |
| 12       | **GND**             | Ground                   | -                    | **信号地**。                                                 |
| 13       | **DBGRQ** / *PODID* | Debug Request / *POD ID* | **输入** (可选)      | **调试请求**（现代常用）。用于请求芯片进入调试模式。*在一些老标准中，此引脚用作PODID（调试器识别）*。 |
| 14       | **VREF**            | Voltage Reference        | **输入**             | **电压参考**。**非常重要！** 调试器通过此引脚检测目标板的工作电压（如1.8V, 3.3V），并据此调整其输出信号的逻辑电平，防止烧毁芯片。**必须连接！** |